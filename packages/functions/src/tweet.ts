import { fetchTeampilot } from "@teampilot/sdk";
import { isSameDay } from "date-fns";
import { ApiHandler } from "sst/node/api";
import { Config } from "sst/node/config";
import { redis, twitterClient, twitterV1Client } from "utils/twitter-auth";
import { z } from "zod";

const ACTUALLY_SEND_TWEET = true;

export const handler = ApiHandler(async (_evt) => {
  const refreshToken = (await redis.get("refreshToken")) as string;

  const {
    client: refreshedClient,
    accessToken,
    refreshToken: newRefreshToken,
  } = await twitterClient.refreshOAuth2Token(refreshToken);

  await redis.set("accessToken", accessToken);
  await redis.set("refreshToken", newRefreshToken);

  const today = new Date();

  const tpResponse = await fetchTeampilot({
    launchpadSlugId: Config.OLAF_TEAMPILOT_LAUNCHPAD_SLUG,
    message: `Think of a topic, write the tweet, test the tweet and generate the image. Today is ${today.toLocaleString(
      "en-US",
      { weekday: "long" }
    )} the ${today.getDate()}th of ${today.toLocaleString("en-US", {
      month: "long",
    })}`,
    schema: z
      .object({
        response: z.object({
          tweet: z.string().max(280),
          threadTweets: z.array(z.string().max(280)),
        }),
      })
      .describe(
        "threadTweets should be an array of tweets each max 280 chars long, so split it up"
      ),
    cacheTtlSeconds: 60, // 1 minute
  });

  const mediaAttachments = tpResponse.mediaAttachments!;
  const imageUrl = mediaAttachments[mediaAttachments.length - 1].url;

  // // Buffer of the image
  const imagaArrayBuffer = await (await fetch(imageUrl)).arrayBuffer();
  const imageBuffer = Buffer.from(imagaArrayBuffer);

  const data = tpResponse.message?.data?.response;

  const lastTweeted = new Date((await redis.get("lastTweeted")) as number);
  const lastTweetedToday = isSameDay(lastTweeted, new Date());

  let didTweet = false;

  if (ACTUALLY_SEND_TWEET && !lastTweetedToday) {
    // You can use media IDs generated by v1 API to send medias!
    const mediaId = await twitterV1Client.v1.uploadMedia(imageBuffer, {
      mimeType: "image/png",
    });

    const tweet = await refreshedClient.v2.tweetThread([
      { text: data.tweet, media: { media_ids: [mediaId] } },
      ...data.threadTweets,
    ]);

    await redis.set("lastTweeted", new Date().toISOString());
    didTweet = true;

    const me = await refreshedClient.currentUserV2();

    await fetch(Config.discord_olaf_webhook, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        embeds: [
          {
            title: "Hey @everyone, I've got a new tweet for yall!",
            description: data.tweet,
            url: `https://twitter.com/${me.data.username}/status/${tweet[0].data.id}`,
            image: {
              url: imageUrl,
            },
          },
        ],
      }),
    });
  }

  return {
    statusCode: 200,
    body: JSON.stringify({
      data: tpResponse.message?.data?.response,
      mediaAttachments: tpResponse.mediaAttachments,
      didTweet,
    }),
  };
});
